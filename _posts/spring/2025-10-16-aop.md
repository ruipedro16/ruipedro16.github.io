---
layout: post
title: Aspect Oriented Programming (AOP)
date: '2025-10-16 14:08:02 +0100'
visible: false
---

## Table of Contents

- [Terminology](#terminology)
  - [Example: Tracking property changes with context](#example-tracking-property-changes-with-context)
- [Types of Advices](#types-of-advices)
- [Poincut Expressions](#poincut-expressions)
  - [Examples](#examples)

---

<br/>

AOP solves the following two problems by modularizing *cross-cutting concerns* (e.g. logging, security)
into separate *aspects*, thus reducing code duplication.

<!-- FIXME: TODO: Dont say intermixed or interwoven -->

- **Code Scattering**: the code for a single cross-cutting concern is replicated across
multiple, often unrelated, modules or classes.
- **Code Tangling**: the code for multiple, distinct concerns is intermixed or interwoven within a
single module or class, making the module difficult to understand, maintain, and update.

<!-- TODO: Fix image size -->

![foo](/assets/img/aop-1.png)

### Terminology

- **Join Point**: A point in the executionof a program (e.g. method call, exception thrown).
- **Poincut**: An expression that selects one or more Joint Points.
- **Advice**: Code to be executed at each selected Joint Point.
- **Aspect**: Module that encapsulates pointcuts and advice.

#### Example: Tracking property changes with context

- The `JointPoint` parameter provides context about the intercepted point.
- In `point.getTarget()`, the name of the bean is returned because, on the
bean implementation, the `toString()` method returns the bean-name.

```java
@Aspect
@Component
public class PropertyChangeTracker {
    private Logger logger = Logger.getLogger(getClass());

    @Before("execution(void set*(*))")
    public void trackChange(JointPoint point) {
        String methodName = point.getSignature().getName();
        Object newValue = point.getArgs()[0];
        Logger.info(methodName + " about to change to " + 
            newValue + " on " + point.getTarget());
    }
}
```

### Types of Advices

### Poincut Expressions

- **Designator**:
  - `execution`: Targets method execution. This is the most common designator.

<p align="center">
  <code>
    execution(modifiers-pattern? return-type-pattern declaring-type-pattern.method-name-pattern(param-pattern) throws-pattern?)
  </code>
</p>

You're absolutely right, the formatting in the previous response was a bit off due to the inline code blocks and bolding. My apologies!

| Part | Purpose | Wildcard Examples |
| :--- | :--- | :--- |
| `modifiers-pattern?` | Optional access modifier (e.g., `public`, `protected`). | `public`, `*` |
| `return-type-pattern` | The return type of the method. | `*`, `void`, `String` |
| `declaring-type-pattern` | The **fully qualified** class/interface name. | `com.app.service.*` (any class in the `service` package) |
| `method-name-pattern` | The name of the method. | `get*`, `*User`, `save` |
| `param-pattern` | The types and number of parameters. | `()`, `(*)`, `(..)` |
| `throws-pattern?` | Optional exception pattern. | `throws java.lang.Exception` |

| Wildcard | Meaning | Context |
| :--- | :--- | :--- |
| *    | Matches **any one** element (e.g., any return type of any method name, any class name part). | `execution(* *.*(..))`: Any method, any class |
| ..   | Matches **zero or more** elements (e.g., any number of packages, or any number/type of method parameters). | `com.app..service.*`: The service package in any sub-package of `com.app` |
| ..   | Matches **zero or more** parameters. | `execution(**(..))`: Any method with any parameters |
| *    | Matches **exactly one** parameter of any type. | `execution(* *(*))`: Any method with exactly one parameter |

- Pointcut expressions can be combined using the `&&`, `||` and `!` boolean
operators.

#### Examples

- `execution(public * *(..))`: Any public method
- `execution(* com.example.service.UserService.*(..))`: All methods in the
`UserService` class.
